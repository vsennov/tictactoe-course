# Код для курсовой работы "Крестики-нолики"

Это заготовка курсовой работы для первого курса по дисциплине "Программирование
и алгоритмизация". В репозитории приведен код, реализующий логику игры в
"Крестики-нолики" до 5 в ряд на большом поле. Студенту необходимо реализовать
бота-игрока, который будет играть согласно алгоритму, который предложит студент,
и который встроится в остальной код игры.

Работа предполагает следующие этапы.

1. **Согласование алгоритма**. Студент предлагает алгоритм, по которому будет
   играть его игрок, и показывает его преподавателю. Алгоритм должен быть
   сформулирован словестно или математически, он **не должен** быть привязан к
   терминам языка C++. Рекомендуется переходить к реализации только после того,
   как преподаватель одобрил алгоритм.

2. **Реализация алгоритма**. Необходимо реализовать алгоритм на языке C++ так, 
   чтобы он встроился в этот проект. Для этого необходимо реализовать интерфейс
   игрока и использовать доступные интерсфейсы для получения информации об 
   текущем состоянии игры; об этом будет написано подробнее ниже. Необходимо
   протестировать игрока, убедиться, что он играет по правилам, играет 
   достаточно хорошо и действительно реализует предложенный алгоритм.

3. **Защита реализации**. Необходимо защитить преподавателю вашу реализацию,
   показав, что игрок играет корректно и играет по вашему алгоритму.

4. **Написание отчета**. В отчете необходимо привести описание алгоритма, 
   привести документацию программного интерфейса, описать особенности 
   реализации вашего алгоритма и привести результаты тестирования. Подробное 
   содержание отчета приведено ниже.

Алгоритм игрока должен удовлетворять следующим критериям:

- алгоритм должен быть применим для игры до 5 в ряд на большом поле (15 на 15
  и более);

- алгоритм должен быть эффективным, время вычисления одного хода должно занимать
  время порядка 50-100 мс на рабочей станции (ноутбуке);

- алгоритм должен быть достаточно сильным; формально это означает, что он
  должен обыгрывать предоставленного игрока базового уровня в большинстве
  случаев за крестики и за нолики; игрок базового уровня предоставляется в виде
  подключаемой библиотеки с закрытым исходным кодом, которая подключается к
  вашему проекту; этот игрок играет *разумно*, но не очень сильно.

В конце семестра среди всех желающих будет устроен **турнир** ботов, на котором
будут разыгрываться бонусы для теоретического экзамена.

Далее в этом документе будут описаны:

- особенности правил игры, которые реализованы в этом проекте;
- краткое описание структуры проекта и его реализации;
- требования к отчету.

## Правила игры в крестики-нолики

Игра в крестики-нолики проходит на прямоугольном поле размера `M` на `N`,
поле состоит из `M * N` клеток. 

Каждый игрок по очереди ставит свой символ в свободную клетку этого поля, то
есть в клетку, куда не был до этого поставлен символ одним из игроков. Первый
игрок ставит символы `X` (крестики), второй игрок ставит символы `O` (нолики).

Игра идет до тех пор, пока один из игроков не составит из своих символов линию
длины `L` (или больше) или пока все клетки поля не будут заполнены. Линия может
быть составлена по горизонтали, по вертикали или по диагонали (под 45 градусов).

Если первым составляет линию длины `L` второй игрок (за нолики), он побеждает
немедленно; если же первый игрок, то второму игроку дается последний ход. Если
второй игрок успевает за последний ход поставить линию длины `L`, то объявляется
ничья, иначе объявляется победа первого игрока.

Если все поле заполнено символами и первый игрок не собрал линию длины `L`, то
объявляется ничья. Если же первый игрок собрал линию длины `L`, но второй игрок
не может сделать ход, так как поле полностью заполнено, побеждает первый игрок.

## Описание проекта

### Структура проекта

Проект написан на языке C++ и организован при помощи системы сборки 
[CMake](https://cmake.org/).

Проект содержит следующие разделы.

- `tttcore` — реализация логики игры и основных интерфейсов. Этот раздел
  является библиотекой, которую можно собрать из исходных файлов и подключать
  к другим часть проекта; однако в исходных файлах нет кода игрока базового
  уровня. Для того, чтобы проводить тесты с игроком базового уровня, необходимо
  будет подключить предкомпилированную версию этой библиотеки, об этом будет
  написано ниже.

- `tttplayer` — реализация игрока; эта часть тоже оформлена в виде библиотеки,
  которая потом подключается к разным исполняемым файлам, например, тестам.
  Изначально содержит пример глупого игрока,  на основе этой заготовки студент
  может реализовать своего игрока.

- `tests` — автоматические тесты на основе CTest. Эти тесты можно и нужно 
  дополнять своими.

- `tttremote` — код для игры по сети. Написан с использованием библиотек
  [Protobuf](https://protobuf.dev/) и [ZeroMQ](https://zeromq.org/). Модуль
  содержит две исполняемых программы: `cli_server` — консольное приложение
  которое запускает сервер, к которому могут подключаться игроки, и  в котором
  с помощью консольного интерфейса можно запускать игры между подключенными
  игроками; `cli_client` — исполняемый файл, который можно собрать с кодом
  вашего игрока для игры на удаленном сервере.

### Сборка проекта

Сборка базовой версии проекта:

```sh
mkdir build
cd build  # переходим в директорию для сборки
cmake ..  # компилируем Make-файлы для нашего проекта
make      # запускаем сборку через Make
```

Для сборки с предкомпилированной библиотекой нужно:

1. Скачать библиотеку в папку `libs`.

2. Собирать проект так же, но запустить `cmake` с флагом 
   `-DBUILD_TTTCORE=PREBUILT`.

Этот флаг можно установить в исходном коде корневого файла `CMakeLists.txt`.

Для сборки программ для игры по сети необходимо установить библиотеки 
[Protobuf](https://protobuf.dev/) (вместе с Protobuf Compiler) и 
[ZeroMQ](https://zeromq.org/), после чего необходимо запустить `cmake`
с флагом `-DBUILD_TTTREMOTE=ON`.

### Выполнение автоматических тестов

Чтобы выполнить автоматические тесты с помощью `CTest`, нужно выполнить
команды:

```sh
cd build
make test
```

### Описание программного интерфейса игры

Каждая игра имеет *состояние*, которое изменяется при действиях игрока и игровых
событиях. В случае игры в "Крестики-нолики" единственная причина изменения
игрового состояния — это ход игрока.

Игровое состояние определено в файле `core/state.hpp` классом
`ttt::game::State`. Игровое состояние может быть создано с настройками
игры, которые определяются структурой `ttt::game::State::Opts`. В методе
`State::process_move` реализована логика изменения состояния в зависимости от
хода игрока. Также объект состояния имеет константные методы, которые позволяют
получать информацию о текущем состоянии.

Игровой цикл, который заключается в поочередном опросе игроков, реализован
в классе `ttt::game::Game` из заголовочного файла `core/game.hpp`. В *игре*
присутствуют два *игрока* (за крестики и за нолики) и *наблюдатели*. Наблюдатели
получают игровые *события* и могут как-то на них реагировать, например,
отрисовывать что-то на экране или вести статистику. Игроки также являются
наблюдателями, однако, они обязаны в нужный момент делать игровой ход.

Наблюдателем является любой объект, реализующий интерфейс
`ttt::game::IObserver`. У этого интерфейса есть единственный метод
`handle_event`, который вызывается игрой, когда происходит игровое событие.
В этот метод передается состояние **после** наступления события и наступившее
игровое событие в виде структуры `ttt::game::Event`.

Игроком является любой объект, реализующий интерфейс `ttt::game::IPlayer`.
Игрок имеет имя (метод `get_name`), игроку игра сообщает, каким знаком он играет
(метод `set_sign`) и игрок *умеет* делать ход (метод `make_move`).

В игру добавляются игроки и наблюдатели, но игра ими *не обладает* (то есть она
не будет ощищать связанную с ними память).

У игры есть метод `process`, который реализует один ход и возвращает результат
этого хода в виде перечисления `ttt::game::MoveResult`.

Пример использования класса игры, добавления игроков и наблюдателей приведен в 
файле `test/test_my_player.cpp`.

Функции для создания игрока базового уровня представлены в заголовочном файле
`core/baseline.hpp`, пример кода, где игрок пользователя сравнивается с игроком
базового уровня приведен в файле `tests/test_baseline.cpp`.

### Протокол взаимодействия игрока с игрой

Когда начинается игра, игроку присваивается знак методом `set_sign`.

Когда игроку необходимо сделать ход, у него вызывается метод `make_move`. В
этот метод передается текущее состояние игры. Из этого метода игрок должен
вернуть координаты клетки, куда он ходит. Каждая координата должна быть от 0 до
соответствующего размера поля не включительно.

Если игрок возвращает координаты клетки вне поля или выбирает клетку, где
уже стоит какой-то знак, игрок дисквалифицируется и другой игрок мгновенно
побеждает.

## Требования к отчету

Отчет должен быть подготовлен на русском языке.

В отчете должны присутствовать следующие разделы в указанном порядке.

1. Титульный лист.

2. Содержание.

3. Введение. В этом разделе необходимо кратко описать идею работы, кому это
   нужно или интересно и почему.  Также в этом разделе необходимо описать
   предметную область (игру в "Крестики-нолики").

4. Постановка задачи. В этом разделе необходимо изложить то, что вам нужно 
   сделать в рамках работы и то, что вам дано. В идеале, другой человек, 
   прочитав вашу постановку задачи должен быть способен в той или иной степени
   повторить вашу работу.

5. Математическое описание. В этом разделе вы описываете математическую модель
   игры и описываете свой алгоритм. Оба этих описания не должны быть привязаны
   к конкретной технологии программирования. Прочитав этот раздел, программист
   на любом языке должен понять, как ему запрограммировать ваш алгоритм, а
   ваша бабушка или товарищ из гуманитарного института, вооружившись бумагой и
   ручкой, должны иметь принципиальную возможность выполнить ваш алгоритм без
   всякого компьютера. Поэтому необходимо избегать терминов конкретного языка
   программирования, в этом разделе не должно быть слов "класс", "функция",
   "метод" и прочих.

6. Особенности реализации. В этом разделе вы описываете то, как именно вы
   реализовали алгоритм из прошлого раздела. Опишите, какие структуры данных
   вы использовали, как генерировали случайные числа, как именно выполняли
   логические операции из вашего алгоритма. В этом же разделе опишите
   программный интерфейс вашего решения, в каких классах и методах реализуется
   алгоритм, какие поля имеют классы, какие аргументы функции и зачем.
   Желательно в этом разделе привести недлинные выкладки кода (листинги).

7. Результаты работы программы. В этом разделе вы приводите результаты тестов,
   которые вы проводили. Важно описать не только результат теста, но то, как
   вы его проводили. По этому описанию другой человек, имея ваш код на руках,
   должен иметь возможность повторить ваши тесты и получить схожие результаты.
   Приведите результат серии игр вашего бота с самим собой, с простым игроком и
   игроком базового уровня. Измерьте и приведите время расчета хода программными
   средствами

8. Заключение. Напишите, все чего удалось добиться в этой работе: что удалось 
   разработать, какой код удалось написать, какие результаты удалось получить, 
   что полезного узнали, какие выводы удалось сделать. Приведите численные 
   характеристики вашей работы: сколько времени потратили на что, сколько строк
   написали, какие главные числа получилось измерить при проверки работы.
   Приведите соображения по поводу слабых мест вашего решения и того, что можно
   было бы в нем улучшить.

9. Список литературы. Укажите, какими источинками вы пользовались при работе,
   на эти источники должны быть ссылки в тексте. Ссылки должны быть оформлены
   в соответствии с ГОСТом, выжимку можно посмотреть
   [тут](https://school.hse.ru/nis/gost).

10. Приложение. В приложении обычно приводят полный код вашего решения. Если у
    вас используются какие-то массивные численные таблицы, которые вы не привели
    ранее, приведите их в отдельном приложении. В идеале, ваша работа вместе с 
    приложением должна полностью содержать результаты вашей интеллектуальной 
    работы, чтобы все, что вы делали, можно было восстановить по отчету.

Все разделы, кроме титульного листа и содержания попадают в содержание, 
допускаются подразделы. Среди этих разделов нумеруются все разделы, кроме
введения, заключения, списка литературы. Допускается добавлять разделы по 
желанию: например, список рисунков, таблиц или листингов. Приложения нумеруются
буквами А, Б, В и так далее.

Все разделы начинаются с новой страницы.

У всех *плавающие* элементов (рисунков, таблиц, листингов) должны быть названия
и  номера, на эти номера должны быть ссылки в тексте. Если эти рисунки вдруг 
"уедут" в другое место ваш *текст* не должен потерять связность.

Отчет должен быть подготовлен для *печати* на бумаге формата А4; в частности
это означает, что гиперссылки должны иметь печатаемый текст. Отчет может быть
подготовлен любым удобным средством так, чтобы он в итоге оказался на бумаге A4.
